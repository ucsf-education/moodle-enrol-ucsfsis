<?php

namespace enrol_ucsfsis;

/* @global $CFG */
require_once($CFG->libdir.'/oauthlib.php');

use moodle_exception;
use moodle_url;
use oauth2_client;


defined('MOODLE_INTERNAL') || die;

/**
 * OAuth 2.0 client for UCSF SIS Enrolment Services
 *
 * @package    enrol_ucsfsis
 * @copyright  2016 The Regents of the University of California
 * @author     Carson Tam <carson.tam@ucsf.edu>
 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */
class ucsfsis_oauth_client extends oauth2_client {
    /** @const API URL */
    const DEFAULT_HOST = 'https://unified-api.ucsf.edu';
    const API_URL = '/general/sis/1.0';
    const TOKEN_URL = '/oauth/1.0/access_token';
    const AUTH_URL = '/oauth/1.0/authorize';

    /** @var string resource username */
    private $base_url = self::DEFAULT_HOST;
    /** @var string resource username */
    private $username = '';
    /** @var string resource password */
    private $password = '';
    /** @var string refresh token */
    protected $refreshtoken = '';
    /** @var bool Caches http request contents that do not change often like schools, terms, departments, subjects...etc */
    public  $longer_cache = false;    // Cache for 24 hours.

    /**
     * Returns the auth url for OAuth 2.0 request
     * @return string the auth url
     */
    protected function auth_url() {
        return $this->base_url . self::AUTH_URL;
    }

    /**
     * Returns the token url for OAuth 2.0 request
     * @return string the auth url
     */
    protected function token_url() {
        return $this->base_url . self::TOKEN_URL;
    }

    /**
     * Returns the url for resource API request
     * @return string the resource API url
     */
    public function api_url() {
        return $this->base_url . self::API_URL;
    }

    /**
     * @inheritdoc
     * @throws \moodle_exception
     */
    public function __construct($clientid, $clientsecret, $username, $password, $host = null, $enablecache = true) {

        // Don't care what the returnurl is right now until we start implementing callbacks
        $returnurl = new moodle_url(null);
        $scope = '';

        parent::__construct($clientid, $clientsecret, $returnurl, $scope);

        $this->refreshtoken = $this->get_stored_refresh_token();
        $this->username = $username;
        $this->password = $password;

        // We need these in the header all time.
        $this->setHeader(array('client_id: ' . $clientid, 'client_secret: ' . $clientsecret));

        if (!empty($host)) {
            $this->base_url = $host;
        }

        if ($enablecache) {
            $this->cache = new sis_client_cache('enrol_ucsfsis');
            $this->longer_cache = new sis_client_cache('enrol_ucsfsis/daily', 24 * 60 * 60);
        }

    }

    /**
     * @inheritdoc
     * @throws moodle_exception
     */
    public function is_logged_in() {
        // Has the token expired?
        $accesstoken = $this->get_accesstoken();
        if (isset($accesstoken->expires) && time() >= $accesstoken->expires) {

            // Try to obtain a new access token with a refresh token.
            if (!empty($this->refreshtoken)) {
                if ($this->refresh_token($this->refreshtoken)) {
                    return true;
                }
            }
            // Clear accesstoken since it already expired.
            $this->log_out();
        }

        // We have a token so we are logged in.
        if (!empty($this->get_accesstoken())) {
            return true;
        }

        // If we've been passed then authorization code generated by the
        // authorization server try and upgrade the token to an access token.
        $code = optional_param('oauth2code', null, PARAM_RAW);
        if ($code && $this->upgrade_token($code)) {
            return true;
        }

        // Try log in using username and password to obtain access token
        if (!empty($this->username) && !empty($this->password)) {
            if ($this->log_in($this->username, $this->password)) {
                return true;
            }
        }

        return false;
    }

    /**
     * @inheritdoc
     */
    protected function request($url, $options = array(), $acceptheader = 'application/json') {

        // We need these in the header all time.
        $this->setHeader(array('client_id: ' . $this->get_clientid(), 'client_secret: ' . $this->get_clientsecret()));

        $response = parent::request($url, $options, $acceptheader);

        return $response;
    }

    /**
     * @inheritdoc
     */
    protected function store_token($token) {
        global $CFG, $SESSION;

        require_once($CFG->libdir.'/moodlelib.php');

        // $this->accesstoken is private, need to call parent to set it.
        parent::store_token($token);

        if ($token !== null) {
            if (isset($token->token)) {
                set_config('accesstoken', $token->token, 'enrol_ucsfsis');
                set_config('accesstokenexpiretime', $token->expires, 'enrol_ucsfsis');
            }
            // Remove it from $SESSION, which was set by parent
            $name = $this->get_tokenname();
            unset($SESSION->{$name});
        } else {
            set_config('accesstoken', null, 'enrol_ucsfsis');
            set_config('accesstokenexpiretime', null, 'enrol_ucsfsis');
        }
    }

    /**
     * Store access token between requests.
     *
     * @param \stdClass|null $token token object to store or null to clear
     */
    protected function store_refresh_token($token) {
        global $CFG;

        require_once($CFG->libdir.'/moodlelib.php');

        $this->refreshtoken = $token;

        if (!empty($token)) {
            set_config('refreshtoken', $token, 'enrol_ucsfsis');
        } else {
            set_config('refreshtoken', null, 'enrol_ucsfsis');
        }
    }

    /**
     * @inheritdoc
     * @throws \dml_exception
     */
    protected function get_stored_token() {
        global $CFG;

        require_once($CFG->libdir.'/moodlelib.php');

        $accesstoken = new \stdClass();
        $accesstoken->token = get_config('enrol_ucsfsis', 'accesstoken');
        $accesstoken->expires = get_config('enrol_ucsfsis', 'accesstokenexpiretime');

        if (!empty($accesstoken->token)) {
            return $accesstoken;
        }

        return null;
    }

    /**
     * Retrieve a refresh token stored.
     *
     * @return string|null token string
     * @throws \dml_exception
     */
    protected function get_stored_refresh_token() {
        global $CFG;

        require_once($CFG->libdir.'/moodlelib.php');

        $refreshtoken = get_config('enrol_ucsfsis', 'refreshtoken');

        if (!empty($refreshtoken)) {
            return $refreshtoken;
        }

        return null;
    }

    /**
     * Get refresh token.
     *
     * This is just a getter to read the private property.
     *
     * @return string
     */
    public function get_refreshtoken() {
        return $this->refreshtoken;
    }

    /**
     * @inheritdoc
     */
    protected function use_http_get() {
        return true;
    }

    /**
     * Refresh the access token from a refresh token
     *
     * @param string $code the token used to refresh the access token
     * @return boolean true if token is refreshed successfully
     * @throws moodle_exception
     */
    protected function refresh_token($code) {

        $params = array('client_id' => $this->get_clientid(),
            'client_secret' => $this->get_clientsecret(),
            'grant_type' => 'refresh_token',
            'refresh_token' => $code,
        );

        // Requests can either use http GET or POST.
        if ($this->use_http_get()) {
            $response = $this->get($this->token_url(), $params);
        } else {
            $response = $this->post($this->token_url(), $params);
        }

        if (!$this->info['http_code'] === 200) {
            throw new moodle_exception('Could not refresh access token.');
        }

        $r = json_decode($response);

        if (!isset($r->access_token)) {
            return false;
        }

        // Store the token an expiry time.
        $accesstoken = new \stdClass();
        $accesstoken->token = $r->access_token;
        $accesstoken->expires = (time() + ($r->expires_in - 10)); // Expires 10 seconds before actual expiry.
        $this->store_token($accesstoken);

        // Store the refresh token.
        if (isset($r->refresh_token)) {
            $this->store_refresh_token($r->refresh_token);
        }

        // Clear cache every time we get a new token
        if (isset($this->cache)) {
            $this->cache->refresh();
        }
        if (isset($this->longer_cache)) {
            $this->longer_cache->refresh();
        }

        return true;
    }

    /**
     * Upgrade a authorization token from oauth 2.0 to an access token
     *
     * @param string $username
     * @param string $password
     * @return boolean true if token is upgraded successfully
     * @throws moodle_exception
     */
    public function log_in($username, $password) {

        $params = array('client_id' => $this->get_clientid(),
            'client_secret' => $this->get_clientsecret(),
            'grant_type' => 'password',
            'username' => $username,
            'password' => $password);

        // Requests can either use http GET or POST.
        // unified-api only works with GET for now.
        if ($this->use_http_get()) {
            $response = $this->get($this->token_url(), $params);
        } else {
            $response = $this->post($this->token_url(), $params);
        }

        if (!$this->info['http_code'] === 200) {
            throw new moodle_exception('Could not upgrade oauth token');
        }

        $r = json_decode($response);

        if (!isset($r->access_token)) {
            return false;
        }

        // Store the token an expiry time.
        $accesstoken = new \stdClass();
        $accesstoken->token = $r->access_token;
        $accesstoken->expires = (time() + ($r->expires_in - 10)); // Expires 10 seconds before actual expiry.
        $this->store_token($accesstoken);

        // Store the refresh token.
        if (isset($r->refresh_token)) {
            $this->store_refresh_token($r->refresh_token);
        }

        // Clear cache every time we log in and get a new token
        if (isset($this->cache)) {
            $this->cache->refresh();
        }

        return true;
    }

    /**
     * Retrieve the data object from the return result from the URI.
     * Anything other than data will return false.
     *
     * @param  string URI to the resources
     * @return array|bool an array objects in data retrieved from the URI, or false when there's an error.
     */
    protected function get_data($uri) {
        $result = $this->get($uri);

        if (empty($result)) {
            return false;
        }

        $result = json_decode($result);

        if (isset($result->data)) {
            return $result->data;
        }

        return false;
    }

    /**
     * Make multiple calls to the URI until a complete set of  data are retrieved from the URI.
     * Return false when there's an error.
     *
     * @param  string URI to the resources
     * @return array|bool an array objects in data retrieved from the URI, or false when there's an error.
     */
    public function get_all_data($uri) {
        $limit    = 100;
        $offset   = 0;
        $data     = null;
        $expected_list_size = null;
        $ret_data = false;


        $query_prefix = strstr($uri,'?') ? '&' : '?';

        do {
            $modified_uri = $uri . $query_prefix . "limit=$limit&offset=$offset";

            $result = $this->get($modified_uri);
            $response = $result;   // save response for debugging

            if (empty($result)) {
                error_log("API call '$modified_uri' returned empty.");
                return false;
            }

            $result = json_decode($result);
            if (isset($result->error)) {
                preg_match('/(Offset \[\d+\] is larger than list size: )([0-9]+)/', $result->error, $errors);
                if (!empty($errors) && isset($errors[2])) {
                    // end of list has reached.
                    $data = null;
                    $expected_list_size = $errors[2];
                } else {
                    // return false on any other error
                    error_log("API call '$modified_uri' returned error: {$result->error}");
                    return false;
                }
            } else if (isset($result->data)) {
                $data = $result->data;

                if (!empty($data)) {
                    if (empty($ret_data)) {
                        $ret_data = array();
                    }
                    $ret_data = array_merge($ret_data, $data);
                    $offset += $limit;
                }
            } else {
                // something went wrong, no data, no error.
                error_log("API call '$modified_uri' returned unexpected response: {$response}");
                return false;
            }

        } while (!empty($data));

        // double check list size (if available).
        if (!empty($expected_list_size)) {
            if ($expected_list_size == count($ret_data)) {
                return $ret_data;
            } else {
                error_log("API call '$modified_uri' did not return same number of items as it claims which is $expected_list_size, actual is ".count($ret_data).".");
                return false;
            }
        }

        return $ret_data;
    }

    /**
     * Get active school terms data in reverse chronological order
     * Cache for 24 hours, don't expect this to change very often
     *
     * @return array|bool Array of term objects, or false if none could be found.
     */
    public function get_active_terms() {
        // Save short term cache
        $cache = $this->cache;
        if (isset($this->cache)) {
            $this->cache = $this->longer_cache;
        }

        // $uri = $this->api_url() . '/terms?fields=id,name,fileDateForEnrollment&sort=-termStartDate';
        $uri = $this->api_url() . '/terms?sort=-termStartDate';
        $terms = $this->get_all_data($uri);

        // restore short term cache
        if (isset($cache)) {
            $this->cache = $cache;
        }

        // Remove terms that have fileDateForEnrollment = NULL.
        if (!empty($terms)) {
            $ret = array();
            foreach ($terms as $term) {
                if (!empty($term->fileDateForEnrollment)) {
                    $ret[] = $term;
                }
            }
            return  $ret;
        }
        return false;
    }

    /**
     * Get all available subjects in a term ordered by name
     * Cache for 24 hours, don't expect this to change very often
     *
     * @param  string Term ID
     * @return array  Array of subject objects.
     */
    public function get_subjects_in_term($term_id) {
        if (isset($this->cache)) {
            // Save short term cache
            $cache = $this->cache;
            $this->cache = $this->longer_cache;
        }

        $termid = trim($term_id);
        $uri = $this->api_url() . "/terms/$termid/subjects?sort=name";
        $ret = $this->get_all_data($uri);

        // restore short term cache
        if (isset($cache)) {
            $this->cache = $cache;
        }

        return  $ret;
    }

    /**
     * Get information on a single course by course id
     *
     * @param  string Course ID
     * @return \stdClass|bool The requested course object, or false if none could be found.
     */
    public function get_course($course_id) {
        $courseid = trim($course_id);
        $uri = $this->api_url() . "/courses/$courseid";
        $ret = $this->get_data($uri);

        return  $ret;
    }

    /**
     * Get all available courses in a term ordered by courseNumber
     * Cache for 24 hours, don't expect this to change very often
     *
     * @param  string Term ID
     * @return array  Array of course objects.
     */
    public function get_courses_in_term($term_id) {
        // Save short term cache
        $cache = $this->cache;
        if (isset($this->cache)) {
            $this->cache = $this->longer_cache;
        }

        $termid = trim($term_id);
        $uri = $this->api_url() . "/terms/$termid/courses?sort=courseNumber";
        $ret = $this->get_all_data($uri);

        // restore short term cache
        if (isset($cache)) {
            $this->cache = $cache;
        }

        return  $ret;
    }

    /**
     * Get enrolment list from a course id
     *
     * @param  int   Course ID
     * @return array|bool An array of enrollment object or false if error.
     */
    public function get_course_enrollment($course_id) {

        // Never cache the enrollment data
        $cache = $this->cache;
        $this->cache = null;


        $courseid = trim($course_id);
        $uri = $this->api_url() . "/courseEnrollments?courseId=$courseid";
        $enrollment = $this->get_all_data($uri);

        // restore the cache object.
        $this->cache = $cache;

        if (empty($enrollment)) {
            return $enrollment;
        }

        // Flatten enrollment objects (Simplify SIS return data to only what we need.)
        $enrol_list = array();

        foreach ($enrollment as $e) {
            if (!empty($e->student) && !empty($e->student->empno)) {
                $obj       = new \stdClass();
                $obj->ucid = $e->student->empno;

                switch ($e->status) {
                    case "A":
                        $obj->status = ENROL_USER_ACTIVE;
                        $enrol_list[trim($e->student->empno)] = $obj;
                        break;
                    case "I":
                        if (!isset($enrol_list[trim($e->student->empno)])) {
                            $obj->status = ENROL_USER_SUSPENDED;
                            $enrol_list[trim($e->student->empno)] = $obj;
                        }
                        break;
                    case "S":
                    case "F":
                    default:
                        // do nothing
                }
            }
        }

        if (!empty($enrol_list)) {
            return $enrol_list;
        } else {
            return false;
        }
    }
}
